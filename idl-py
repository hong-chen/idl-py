#!/Users/hoch4240/Chen/soft/python/3/bin/python

##!/usr/bin/env python3

# by Hong Chen (me@hongchen.cz)

import sys
import os
import shutil
import pexpect
from prompt_toolkit import prompt, AbortAction
from prompt_toolkit.history import InMemoryHistory
from pygments.lexers import IDLLexer
from prompt_toolkit.layout.lexers import PygmentsLexer
from termcolor import colored, cprint

def FIND_FUNCTIONS_IDL(fname):

    if not os.path.isfile(fname):

        cprint('Error [idl-py]: "%s" does not exist.' % fname, 'red')
        sys.exit()

    if fname.split('.')[-1].lower() == 'pro':

        patterns = ['pro', 'function']

        lines_func = []

        f = open(fname, 'r')
        lines = f.readlines()
        for i in range(len(lines)):
            line  = lines[i].lower().strip()

            if any(line[:len(pattern)] == pattern for pattern in patterns):

                if line[-1] == '$':
                    line_func = line[:-1]
                    j = i+1
                    while lines[j].lower().strip()[-1] == '$':
                        line_func = line_func + lines[j].lower().strip()[:-1]
                        j += 1
                    line_func = line_func + lines[j].lower().strip()
                else:
                    line_func = line

                for pattern in patterns:
                    line_func = line_func.replace(pattern, '').strip()

                words    = line_func.replace(' ', '').split(',')
                words[0] = words[0].upper()
                line_func = ', '.join(words)
                lines_func.append(line_func)
        f.close()

        return lines_func

    else:

        cprint('Error [idl-py]: wrong file type.', 'red')
        sys.exit()

def CPRINT_DOT_R(fname, idl):

    command = '.r %s' % fname
    idl.sendline(command)
    idl.expect('IDL> ', timeout=10)

    message_before = colored('Out:\n', 'blue')
    message = message_before + idl.before[len(command):].strip()
    print(message)

    lines_func = FIND_FUNCTIONS_IDL(fname)
    message = '\n\n'.join(lines_func)
    print()
    cprint(message, 'green')
    print()

    return idl

def START():

    Nargv = len(sys.argv)

    if Nargv==1 or Nargv==2:

        idl = pexpect.spawnu('idl')
        idl.expect('IDL> ', timeout=10)
        print(idl.before.rstrip('\n'))

        if Nargv == 2:

            fname = sys.argv[1]
            print('IDL-PY> ')
            idl = CPRINT_DOT_R(fname, idl)

        history = InMemoryHistory()

        while True:

            try:

                command = prompt('IDL-PY> ', lexer=PygmentsLexer(IDLLexer), history=history, on_abort=AbortAction.RETRY)

                command = command.strip()

                if command == 'exit':

                    exit()

                elif command[:2] == '.r':

                    fname = command[2:].strip()
                    idl = CPRINT_DOT_R(fname, idl)

                else:

                    idl.sendline(command)
                    idl.expect('IDL> ', timeout=86400)
                    message = idl.before[len(command):].strip()
                    if len(message) > 0:
                        message_before = colored('Out:\n', 'blue')
                        if 'Execution halted' in message:
                            if shutil.which(command) != None:
                                message = 'this is a shell command...'
                                message = message_before + message
                            else:
                                message = message_before + colored(idl.before[len(command):].strip(), 'red')

                        print(message)

                    print()

            except EOFError:

                exit('Error [idl-py]: Exiting...')

    else:

        cprint('Error [idl-py]: too many arguments.', 'red')

if __name__ == "__main__":

    START()
